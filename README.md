Approach to the Problem

I approached the problem by considering several data structures: Vectors, Hash Tables, and Binary Search Trees (BSTs). Each structure offered different strengths, and selecting the right one was critical to optimizing the system's performance. Data structures are fundamental to software development because they define how data is stored, accessed, and manipulated, significantly impacting the efficiency of the program. Understanding their complexities allows developers to choose the right tool for a given problem.


The Vector structure was simple to implement but inefficient for searching and printing ordered data. The Hash Table offered fast lookup times for searches but lacked inherent order, making it unsuitable for tasks requiring sorted output. Ultimately, the Binary Search Tree provided an efficient balance of fast searches (O(log n)) and natural order preservation (O(n) for ordered printing), making it the most suitable choice for this project.


Overcoming Roadblocks

Throughout the project, one of the main roadblocks was managing the complexity of certain data structures, particularly the Binary Search Tree. Implementing efficient insertions, ensuring the tree remained balanced, and writing recursive traversal functions required careful attention to detail. To overcome these challenges, I revisited algorithmic concepts like tree balancing and recursive functions. Breaking down the problem into smaller, manageable parts and systematically testing different functions helped ensure that each aspect of the program was working correctly.


Expanded Approach to Software Design

This project expanded my understanding of how the choice of data structure influences software design. While a simple data structure like a vector may seem like an easy solution, understanding the specific needs of the application—such as fast searches or ordered output—leads to better design decisions. The project reinforced the importance of analyzing trade-offs between time complexity and ease of implementation. It has encouraged me to think more critically about how to structure data and operations to meet both performance and functional requirements.


Evolution of Code Writing: Maintainability, Readability, and Adaptability

Working on this project has significantly influenced how I write code that is maintainable, readable, and adaptable. One key takeaway is the importance of modularity—breaking the program into distinct functions that handle specific tasks, such as reading data from a file or searching for a course, makes the code easier to understand and modify. Additionally, clearly defining the responsibilities of each data structure and documenting its behavior helps with readability. Finally, I focused on making the code adaptable by allowing the course information system to support additional features or data changes without requiring significant modifications to the core functions.






